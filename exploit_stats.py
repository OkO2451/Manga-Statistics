# the imports
# seaborn
import seaborn as sns
# matplotlib
import matplotlib.pyplot as plt
# pandas
import pandas as pd
# numpy
import numpy as np
# re
import re
# scikit-learn
from sklearn.preprocessing import StandardScaler
# 



# the data
chapterData = pd.read_csv("chapterData_2.csv")
mangaData = pd.read_csv("mangaData_2.csv")

# get the number of rows
print(
    f"mangaData: {mangaData.shape[0]} || chapterData: {chapterData.shape[0]}")

# basic plots to explore the data
# histograme to see the distribution of the views
sns.distplot(chapterData["views"], kde=False)
# cant plot since views are strings in form of 1.2M and 1.3K
# convert the views to numbers using numpy

chapterData["views"] = chapterData["views"].apply(
    lambda x: float(x[:-1])*1000 if x[-1] == "K" else float(x[:-1])*1000000)
mangaData["views"] = mangaData["views"].apply(lambda x: float(
    x[:-1])*1000 if x[-1] == "K" else float(x[:-1])*1000000)

# plot again histograme to see the distribution of the views for mangaData
sns.distplot(mangaData["views"], kde=False)
# alt to distplot
sns.histplot(mangaData["views"], kde=False)
# plto with it the mean and median as vertical lines
plt.axvline(mangaData["views"].mean(), color='r', linestyle='--')
plt.axvline(mangaData["views"].median(), color='g', linestyle='-')
# add labels for the lines
plt.text(mangaData["views"].mean()+1000000, 100, "mean", rotation=90)
plt.text(mangaData["views"].median()+1000000, 100, "median", rotation=90)
# labels for views with the unit
plt.xlabel("views (in millions)")
plt.ylabel("count")
plt.title("Distribution of views for mangaData")


# boxplot to see the distribution of the views for mangaData
sns.boxplot(mangaData["views"])

# find the outliers and print their lines
# get the quantiles
q1 = mangaData["views"].quantile(0.25)
q3 = mangaData["views"].quantile(0.75)
# get the interquartile range
iqr = q3 - q1
# get the lower and upper bounds
lower_bound = q1 - (1.5 * iqr)
upper_bound = q3 + (1.5 * iqr)
# get the outliers
outliers = mangaData[(mangaData["views"] < lower_bound) |
                     (mangaData["views"] > upper_bound)]
# print the outliers
print(f"name: {outliers['name']}\nviews: {outliers['views']}\n")

# plot the boxplot without the outliers
no_outliers = mangaData[(mangaData["views"] > lower_bound)
                        & (mangaData["views"] < upper_bound)]

sns.boxplot(no_outliers["views"])
# adding labels
plt.xlabel("views (in millions)")
plt.title("Distribution of views for mangaData without outliers")


sns.histplot(no_outliers["views"], kde=False)
# plto with it the mean and median as vertical lines
plt.axvline(no_outliers["views"].mean(), color='r', linestyle='--')
plt.axvline(no_outliers["views"].median(), color='g', linestyle='-')

# add labels for the lines
plt.text(no_outliers["views"].mean()+1000000, 100, "mean", rotation=90)
plt.text(no_outliers["views"].median()+1000000, 100, "median", rotation=90)

# labels for views with the unit
plt.xlabel("views (in millions)")
plt.ylabel("count")
plt.title("Distribution of views for mangaData without outliers")
# draw the standerd deviation
plt.axvline(no_outliers["views"].mean() +
            no_outliers["views"].std(), color='r', linestyle='--')
plt.axvline(no_outliers["views"].mean() -
            no_outliers["views"].std(), color='r', linestyle='--')
# add labels for the lines
plt.text(no_outliers["views"].mean() +
         no_outliers["views"].std()+1000000, 100, "std", rotation=90)


# to see what a standerd deviation is
# lets use the example of heights
# the data
heights = pd.DataFrame({"height": [1.5, 1.6, 1.7, 1.8, 1.9, 2.0, 2.1]})
# plot the data
sns.histplot(heights["height"], kde=False)
# add labels
plt.xlabel("height (in meters)")
plt.ylabel("count")
plt.title("Distribution of heights")
# draw the standerd deviation
plt.axvline(heights["height"].mean() +
            heights["height"].std(), color='r', linestyle='--')
plt.axvline(heights["height"].mean() -
            heights["height"].std(), color='r', linestyle='--')
# add labels for the lines
plt.text(heights["height"].mean()+heights["height"].std() +
         0.05, 1, "std", rotation=90)
# add the mean and median
plt.axvline(heights["height"].mean(), color='r', linestyle='--')
plt.axvline(heights["height"].median(), color='g', linestyle='-')
# add labels for the lines
plt.text(heights["height"].mean()+0.05, 1, "mean", rotation=90)
plt.text(heights["height"].median()+0.05, 1, "median", rotation=90)


# adding a log scale
sns.histplot(no_outliers["views"], kde=False, log_scale=True)

# using a log scale for the boxplot
sns.boxplot(no_outliers["views"], log=True)

# making the score and nb_votes numbers
mangaData["score"] = mangaData["score"].apply(lambda x: float(
    re.search(r"\d+\.\d+", x).group()) if type(x) == str else x)
mangaData["nb_votes"] = mangaData["nb_votes"].apply(
    lambda x: int(x.replace(",", "")) if type(x) == str else x)
# plot the score and nb_votes
sns.scatterplot(x="score", y="nb_votes", data=mangaData)
# add labels
plt.xlabel("score")
plt.ylabel("nb_votes")
plt.title("score vs nb_votes")


# genre is a string of genres seperated by a "-"
# split the genre into a list of genres
mangaData["genre"] = mangaData["genre"].apply(lambda x: x.split("-"))
# get the number of genres
mangaData["nb_genres"] = mangaData["genre"].apply(lambda x: len(x)) 
# plot the number of genres
# plot the number of genres
sns.histplot(mangaData["nb_genres"])

# genres with the most views
# get the genres
genres = mangaData["genre"].explode()
# get the views
views = mangaData["views"].explode()
# create a dataframe
genres_views = pd.DataFrame({"genre": genres, "views": views})
# group by genre and sum the views
genres_views = genres_views.groupby("genre").sum()
# sort the values
genres_views = genres_views.sort_values("views", ascending=False)
# plot the genres with the most views
sns.barplot(x=genres_views.index[:10], y="views", data=genres_views[:10])
# add labels
plt.xlabel("genre")
plt.ylabel("views")
plt.title("genre vs views")
# make it wider so the genres wont overlap
plt.gcf().set_size_inches(20, 10)

# plot the worst genres
sns.barplot(x=genres_views.index[-10:], y="views", data=genres_views[-10:])
# add labels
plt.xlabel("genre")
plt.ylabel("views")
plt.title("genre vs views")
# make it wider so the genres wont overlap
plt.gcf().set_size_inches(20, 10)

# go through all the titles and record words with how many views they have and how many times they appear
# get the titles
titles = mangaData["name"]

# get the words in the titles and put it in a dict
dict_words = { x:0 for title in titles for x in title.split()}
for x in titles:
    for word in x.split():
        dict_words[word] += 1



# make the datafram with views set to zero so we can count
words_views = pd.DataFrame({"words": words["0"],
                            "views": 0,
                            "frequency": 0,
                            "score": 0,
                            "nb_votes": 0})
# iterate through mangaData and add the views if a word is in the title
for index, row in mangaData.iterrows():
    if 


# dimensions of words
print(f"words_views.shape: {words_views.shape}")


# views vs nb of genre
sns.scatterplot(x="nb_genres", y="views", data=mangaData)

# views of the action genre compared to the other genres
# get the action genre
action = mangaData[mangaData["genre"].apply(lambda x: "Action" in x)]
# get the fantasy genre
fantasy = mangaData[mangaData["genre"].apply(lambda x: "Fantasy" in x)]
# get the other genres
other = mangaData[mangaData["genre"].apply(lambda x: "Action" not in x and "Fantasy" not in x)]
# plot the views of the action genre compared to the other genres
sns.histplot(action["views"], color="r", label="action", kde=False)
sns.histplot(other["views"], color="b", label="other", kde=False)
sns.histplot(fantasy["views"], color="g", label="fantasy", kde=False)
# add labels
plt.xlabel("views")
plt.ylabel("count")
plt.title("action vs other")
plt.legend()

